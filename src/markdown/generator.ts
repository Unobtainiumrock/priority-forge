import * as fs from 'fs';
import * as path from 'path';
import { ProgressDatabase, Project, WeightedTask, DataGap, Decision, Priority, HeuristicWeights } from '../types/schema';

const DATA_DIR = path.join(__dirname, '../../data');
const MD_FILE = path.join(DATA_DIR, 'PROGRESS_TRACKER.md');

function getStatusEmoji(status: string): string {
  switch (status) {
    case 'active': return 'ğŸŸ¢';
    case 'complete': return 'âœ…';
    case 'blocked': return 'ğŸ”´';
    case 'shelved': return 'â¸ï¸';
    case 'not_started': return 'âŒ';
    case 'in_progress': return 'ğŸ”„';
    case 'waiting': return 'â³';
    default: return 'â“';
  }
}

function getPriorityEmoji(priority: Priority): string {
  switch (priority) {
    case 'P0': return 'ğŸ”´';
    case 'P1': return 'ğŸŸ ';
    case 'P2': return 'ğŸŸ¡';
    case 'P3': return 'ğŸŸ¢';
  }
}

function getTaskStatusEmoji(status: string): string {
  switch (status) {
    case 'not_started': return 'âŒ';
    case 'in_progress': return 'ğŸ”„';
    case 'complete': return 'âœ…';
    case 'blocked': return 'ğŸš«';
    case 'waiting': return 'â³';
    default: return 'â“';
  }
}

function groupTasksByPriority(tasks: WeightedTask[]): Record<Priority, WeightedTask[]> {
  return tasks.reduce((acc, task) => {
    if (!acc[task.priority]) acc[task.priority] = [];
    acc[task.priority].push(task);
    return acc;
  }, {} as Record<Priority, WeightedTask[]>);
}

export function generateMarkdown(db: ProgressDatabase): string {
  const lines: string[] = [];
  
  // Header
  lines.push('# Unified Progress Tracker: Market Optimization Platform');
  lines.push('');
  lines.push('**Purpose:** Single source of truth for all project progress.');
  lines.push(`**Last Updated:** ${new Date(db.lastUpdated).toLocaleString()}`);
  lines.push(`**Version:** ${db.version} (Heap-Based Priority Queue)`);
  lines.push('');
  lines.push('> This file is auto-generated by the MCP Progress Tracker server.');
  lines.push('> Do not edit manually - use the API endpoints instead.');
  lines.push('');
  
  // V2: Top Priority Highlight
  const sortedTasks = [...db.tasks].sort((a, b) => a.priorityScore - b.priorityScore);
  if (sortedTasks.length > 0) {
    const topTask = sortedTasks[0];
    lines.push('## ğŸ¯ Top Priority Task');
    lines.push('');
    lines.push(`> **${topTask.task}**`);
    lines.push(`> - Project: ${topTask.project}`);
    lines.push(`> - Priority: ${topTask.priority} (Score: ${topTask.priorityScore.toFixed(2)})`);
    lines.push(`> - Status: ${getTaskStatusEmoji(topTask.status)} ${topTask.status}`);
    if (topTask.blocking) {
      lines.push(`> - Blocks: ${topTask.blocking}`);
    }
    lines.push('');
  }
  
  // Quick Status Overview
  lines.push('## Quick Status Overview');
  lines.push('');
  if (db.projects.length > 0) {
    lines.push('| Project | Location | Status | Primary Focus |');
    lines.push('|---------|----------|--------|---------------|');
    for (const project of db.projects) {
      lines.push(`| ${project.name} | ${project.path} | ${getStatusEmoji(project.status)} ${project.status} | ${project.primaryFocus} |`);
    }
  } else {
    lines.push('*No projects yet.*');
  }
  lines.push('');
  
  // Priority Queue (V2 with scores)
  lines.push('## ğŸ”´ Priority Queue (Cross-Project)');
  lines.push('');
  
  const tasksByPriority = groupTasksByPriority(db.tasks);
  const priorities: Priority[] = ['P0', 'P1', 'P2', 'P3'];
  const priorityLabels: Record<Priority, string> = {
    P0: 'P0: Critical Path Items',
    P1: 'P1: High Priority',
    P2: 'P2: Medium Priority',
    P3: 'P3: Lower Priority',
  };
  
  for (const priority of priorities) {
    const tasks = (tasksByPriority[priority] || []).sort((a, b) => a.priorityScore - b.priorityScore);
    lines.push(`### ${priorityLabels[priority]}`);
    lines.push('');
    
    if (tasks.length > 0) {
      lines.push('| ID | Task | Project | Status | Score | Notes |');
      lines.push('|----|------|---------|--------|-------|-------|');
      for (const task of tasks) {
        const notes = task.blocking 
          ? `Blocks: ${task.blocking}` 
          : (task.notes || '-');
        const displayId = task.id.length > 8 ? task.id.slice(0, 8) : task.id;
        lines.push(`| ${displayId} | ${task.task} | ${task.project} | ${getTaskStatusEmoji(task.status)} | ${task.priorityScore.toFixed(1)} | ${notes} |`);
      }
    } else {
      lines.push('*No tasks at this priority level.*');
    }
    lines.push('');
  }
  
  // V2: Heuristic Weights Configuration
  if (db.heuristicWeights) {
    lines.push('## âš–ï¸ Priority Scoring Weights (V2)');
    lines.push('');
    lines.push('| Factor | Weight | Description |');
    lines.push('|--------|--------|-------------|');
    lines.push(`| Blocking | ${db.heuristicWeights.blocking} | Tasks that unblock other work |`);
    lines.push(`| Cross-Project | ${db.heuristicWeights.crossProject} | Tasks affecting multiple projects |`);
    lines.push(`| Time Sensitive | ${db.heuristicWeights.timeSensitive} | Deadline proximity |`);
    lines.push(`| Effort/Value | ${db.heuristicWeights.effortValue} | Quick wins vs long slogs |`);
    lines.push(`| Dependency | ${db.heuristicWeights.dependency} | Depth in dependency chain |`);
    lines.push('');
    lines.push('> *Lower priority score = higher priority. Adjust weights via `PUT /heuristic-weights`*');
    lines.push('');
  }
  
  // Data Collection Roadmap
  lines.push('## ğŸ“Š Data Collection Roadmap');
  lines.push('');
  
  if (db.dataGaps.length > 0) {
    lines.push('| Priority | Data Element | Coverage | Impact | Effort |');
    lines.push('|----------|--------------|----------|--------|--------|');
    for (const gap of db.dataGaps) {
      lines.push(`| ${getPriorityEmoji(gap.priority)} ${gap.priority} | ${gap.element} | ${gap.coverage} | ${gap.impact} | ${gap.effort} |`);
    }
  } else {
    lines.push('*No data gaps identified.*');
  }
  lines.push('');
  
  // Decision Log
  lines.push('## ğŸ“‹ Decision Log');
  lines.push('');
  
  if (db.decisions.length > 0) {
    lines.push('| Date | Decision | Rationale |');
    lines.push('|------|----------|-----------|');
    for (const decision of db.decisions) {
      lines.push(`| ${decision.date} | ${decision.decision} | ${decision.rationale} |`);
    }
  } else {
    lines.push('*No decisions logged yet.*');
  }
  lines.push('');
  
  // Project Details
  lines.push('## ğŸ“ Project Details');
  lines.push('');
  
  for (const project of db.projects) {
    lines.push(`### ${project.name}`);
    lines.push('');
    lines.push(`**Status:** ${getStatusEmoji(project.status)} ${project.status}`);
    lines.push(`**Path:** \`${project.path}\``);
    lines.push(`**Focus:** ${project.primaryFocus}`);
    lines.push('');
    
    const projectTasks = db.tasks
      .filter(t => t.project === project.id || t.project === project.name)
      .sort((a, b) => a.priorityScore - b.priorityScore);
    if (projectTasks.length > 0) {
      lines.push('**Tasks:**');
      for (const task of projectTasks) {
        const checkbox = task.status === 'complete' ? '[x]' : '[ ]';
        lines.push(`- ${checkbox} ${task.task} (${task.priority}, score: ${task.priorityScore.toFixed(1)})`);
      }
      lines.push('');
    }
  }
  
  // V3 Training Data Stats (if any completion records exist)
  if (db.completionRecords.length > 0) {
    lines.push('## ğŸ“ˆ Completion Statistics (V3 Training Data)');
    lines.push('');
    lines.push(`**Total Completed Tasks:** ${db.completionRecords.length}`);
    
    const avgTime = db.completionRecords.reduce((sum, r) => sum + r.actualCompletionTime, 0) / db.completionRecords.length;
    lines.push(`**Average Completion Time:** ${avgTime.toFixed(1)} hours`);
    
    const totalSwitches = db.completionRecords.reduce((sum, r) => sum + r.contextSwitchCount, 0);
    lines.push(`**Total Context Switches:** ${totalSwitches}`);
    lines.push('');
  }
  
  // Footer
  lines.push('---');
  lines.push('');
  lines.push('*Generated by MCP Progress Tracker Server v2.0*');
  lines.push('*API: http://localhost:3456*');
  lines.push('*MCP: http://localhost:3456/mcp*');
  
  return lines.join('\n');
}

export async function writeMarkdown(db: ProgressDatabase): Promise<void> {
  const content = generateMarkdown(db);
  if (!fs.existsSync(DATA_DIR)) {
    fs.mkdirSync(DATA_DIR, { recursive: true });
  }
  fs.writeFileSync(MD_FILE, content, 'utf-8');
}
